use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use walkdir::WalkDir;
use syn::{Attribute, ItemStruct};

/// Directory to ignore during traversal
const IGNORE_DIR: &str = ".corrosive_component";

/// The output file where the auto-prelude will be written
const OUTPUT_FILE: &str = "./corrosive-components/auto-prelude.rs";

/// Main function
fn main() -> io::Result<()> {
    // Base directory to start the search (current directory in this case)
    let base_dir = Path::new(".");

    // Collect all modules with `#[component]`
    let mut components = vec![];

    for entry in WalkDir::new(base_dir)
        .into_iter()
        .filter_entry(|e| !is_ignored(e))
        .filter_map(Result::ok)
    {
        if entry.path().extension().and_then(|ext| ext.to_str()) == Some("rs") {
            if let Some(module_path) = process_file(entry.path()) {
                components.push(module_path);
            }
        }
    }

    // Write discovered modules to the auto-prelude file
    write_auto_prelude(&components)?;

    println!("Auto-prelude generated with {} components.", components.len());
    Ok(())
}

/// Check if a directory or file should be ignored
fn is_ignored(entry: &walkdir::DirEntry) -> bool {
    entry.file_name() == IGNORE_DIR
}

/// Process a Rust file, searching for structs with the `#[component]` attribute
fn process_file(path: &Path) -> Option<String> {
    // Read the file contents
    let content = fs::read_to_string(path).ok()?;

    // Parse the file with `syn`
    let syntax = syn::parse_file(&content).ok()?;

    for item in syntax.items {
        if let syn::Item::Struct(ItemStruct { attrs, .. }) = item {
            if has_component_attr(&attrs) {
                // Convert path to a module path (e.g., `src/foo.rs` -> `foo`)
                return Some(path_to_module(path));
            }
        }
    }
    None
}

/// Check if the struct has the `#[component]` attribute
fn has_component_attr(attrs: &[Attribute]) -> bool {
    attrs.iter().any(|attr| attr.path.is_ident("component"))
}

/// Convert a file path to a Rust module path (e.g., `src/foo.rs` -> `foo`)
fn path_to_module(path: &Path) -> String {
    let module_path = path
        .strip_prefix("./") // Remove leading `./`
        .unwrap_or(path)
        .with_extension("") // Remove `.rs` extension
        .to_string_lossy()
        .replace("/", "::") // Convert to Rust module path format
        .replace("\\", "::"); // Handle Windows paths
    module_path
}

/// Write the auto-prelude file
fn write_auto_prelude(modules: &[String]) -> io::Result<()> {
    let mut file = File::create(OUTPUT_FILE)?;

    writeln!(file, "// This file is auto-generated by the prelude generator")?;
    writeln!(file, "// Do not edit manually\n")?;

    for module in modules {
        writeln!(file, "pub use crate::{}::*;", module)?;
    }
    Ok(())
}
